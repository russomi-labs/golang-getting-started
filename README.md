# golang-getting-started

Getting Started tutorials for Go

## Tutorial: Get started with Go

In this tutorial, you'll get a brief introduction to Go programming. Along the way, you will:

- Install Go (if you haven't already).
- Write some simple "Hello, world" code.
- Use the go command to run your code.
- Use the Go package discovery tool to find packages you can use in your own code.
- Call functions of an external module.

### Install Go

- [Download and install](https://golang.org/doc/install)
- Install via Brew on macOS:

``` bash

# output a list of what you can install
brew search golang

# Go ahead and install it
brew install golang

# check the version of Go
go version

# to update Go, you can run the following commands
brew update
brew upgrade golang

```

### Write some code

Create a hello directory for your first Go source code.

``` BASH
mkdir hello
cd hello
```

In your text editor, create a file hello.go in which to write your code.

``` Go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

Run your code to see the greeting.

``` BASH
$ go run hello.go

Hello, World!
```

``` BASH
$ go help

```

### Call code in an external package

When you need your code to do something that might have been implemented by someone else, you can look for a package that has functions you can use in your code.

- Visit [pkg.go.dev](https://pkg.go.dev) and search for a "quote" package.
- Locate and click the `rsc.io/quote` package in search results (if you see rsc.io/quote/v3, ignore it for now).

``` Go
package main

import "fmt"

import "rsc.io/quote"

func main() {
    fmt.Println(quote.Go())
}
```

- Put your own code in a module for tracking dependencies.

``` BASH
go mod init hello
```

- Run your code to see the message generated by the function you are calling.

``` BASH
$ go run hello.go

go: finding module for package rsc.io/quote
go: found rsc.io/quote in rsc.io/quote v1.5.2
Don't communicate by sharing memory, share memory by communicating.
```

## Tutorial: Create a Go module

In this [tutorial](https://golang.org/doc/tutorial/create-module) you'll create two modules.

- The first is a library which is intended to be imported by other libraries or applications.
- The second is a caller application which will use the first.

This tutorial's sequence includes six brief topics that each illustrate a different part of the language.

- Create a module -- Write a small module with functions you can call from another module.
- Call your code from another module -- Import and use your new module.
- Return and handle an error -- Add simple error handling.
- Return a random greeting -- Handle data in slices (Go's dynamically-sized arrays).
- Return greetings for multiple people -- Store key/value pairs in a map.
- Add a test -- Use Go's built-in unit testing features to test your code.
- Compile and install the application -- Compile and install your code locally.

### Create a module

``` BASH
# Create a greetings directory for your Go module source code.
# This is where you'll write your module code.
mkdir greetings
cd greetings

# Start your module using the go mod init command to create a go.mod file.
go mod init github.com/russomi-labs/golang-getting-started/greetings
```

Create a file in which to write your code and call it `greetings.go` .

``` Go
package greetings

import "fmt"

// Hello returns a greeting for the named person.
func Hello(name string) string {
    // Return a greeting that embeds the name in a message.
    message := fmt.Sprintf("Hi, %v. Welcome!", name)
    return message
}
```

This is the first code for your module.  It returns a greeting to any caller that asks for one.

In this code, you:

- Declare a greetings package to collect related functions.
- Implement a Hello function to return the greeting.
- This function takes a name parameter whose type is string, and returns a string.
- In Go, a function whose name starts with a capital letter can be called by a function not in the same package. This is known in Go as an [exported name](https://tour.golang.org/basics/3).
- Declare a message variable to hold your greeting.
- In Go, the := operator is a shortcut for declaring and initializing a variable in one line (Go uses the value on the right to determine the variable's type).
- Taking the long way, you might have written this as:

``` Go
var message string
message = fmt. Sprintf("Hi, %v. Welcome!", name)
```

- Use the `fmt` package's `Sprintf` function to create a greeting message.
- The first argument is a format string, and `Sprintf` substitutes the name parameter's value for the `%v` format verb.
- Inserting the value of the name parameter completes the greeting text.
- Return the formatted greeting text to the caller.

### Call your code from another module

Create a hello directory for your Go module source code. This is where you'll write your caller.

``` BASH
cd ..
mkdir hello
cd hello

touch hello.go
```

``` Go
package main

import (
    "fmt"

    "github.com/russomi-labs/golang-getting-started/greetings"
)

func main() {
    // Get a greeting message and print it.
    message := greetings.Hello("Gladys")
    fmt.Println(message)
}
```

Create a new module for this hello package.

``` BASH
go mod init hello
```

Edit the hello module to use the unpublished greetings module.

``` Go
module hello

go 1.14

replace github.com/russomi-labs/golang-getting-started/greetings => ../greetings
```

Here, the [replace directive](https://golang.org/ref/mod#tmp_15) tells Go to replace the module path (the URL example.com/greetings) with a path you specify. In this case, that's a greetings directory next to the hello directory.

In the hello directory, run go build to make Go locate the module and add it as a dependency to the go.mod file.

``` BASH
go build
```

Look at `go.mod` again to see the changes made by `go build` , including the `require` directive Go added.

``` Go
module hello

go 1.15

replace github.com/russomi-labs/golang-getting-started/greetings => ../greetings

require github.com/russomi-labs/golang-getting-started/greetings v0.0.0-00010101000000-000000000000

```

In the hello directory, run the hello executable (created by go build) to confirm that the code works.

``` BASH
$ ./hello
Hi, Gladys. Welcome!
```

### Return and handle an error

Handling errors is an essential feature of solid code. In this section, you'll add a bit of code to return an error from the greetings module, then handle it in the caller.

There's no sense sending a greeting back if you don't know who to greet. Return an error to the caller if the name is empty. Copy the following code into greetings.go and save the file.

``` Go
package greetings

import (
    "errors"
    "fmt"
)

// Hello returns a greeting for the named person.
func Hello(name string) (string, error) {
    // If no name was given, return an error with a message.
    if name == "" {
        return "", errors.New("empty name")
    }

    // If a name was received, return a value that embeds the name
    // in a greeting message.
    message := fmt.Sprintf("Hi, %v. Welcome!", name)
    return message, nil
}
```

- Change the function so that it returns two values: a string and an error.
- Your caller will check the second value to see if an error occurred. (Any Go function can return [multiple values](https://golang.org/doc/effective_go.html#multiple-returns).)
- Import the Go standard library errors package so you can use its [errors. New function](https://golang.org/pkg/errors/#example_New).
- Add an if statement to check for an invalid request and return an error if the request is invalid.
- The errors. New function returns an error with your message inside.
- Add nil (meaning no error) as a second value in the successful return.
- That way, the caller can see that the function succeeded.

In your hello/hello.go file, handle the error now returned by the Hello function, along with the non-error value.

``` Go
package main

import (
    "fmt"
    "log"

    "github.com/russomi-labs/golang-getting-started/greetings"
)

func main() {
    // Set properties of the predefined Logger, including
    // the log entry prefix and a flag to disable printing
    // the time, source file, and line number.
    log.SetPrefix("greetings: ")
    log.SetFlags(0)

    // Request a greeting message.
    message, err := greetings.Hello("")
    // If an error was returned, print it to the console and
    // exit the program.
    if err != nil {
        log.Fatal(err)
    }

    // If no error was returned, print the returned message
    // to the console.
    fmt.Println(message)
}
```

- Configure the [log package](https://golang.org/pkg/log/) to print the command name ("greetings: ") at the start of its log messages, without a time stamp or source file information.
- Assign both of the Hello return values, including the error, to variables.
- Change the Hello argument from Gladys's name to an empty string, so you can try out your error-handling code.
- Look for a non-nil error value. There's no sense continuing in this case.
- Use the functions in the standard library's log package to output error information.
- If you get an error, you use the log package's [Fatal function](https://pkg.go.dev/log?tab=doc#Fatal) to print the error and stop the program.

At the command line in the hello directory, run hello.go to confirm that the code works.

``` BASH
$ go run hello.go
greetings: empty name
exit status 1
```

### Return a random greeting

In this section, you'll change your code so that instead of returning a single greeting every time, it returns one of several predefined greeting messages.

- To do this, you'll use a Go [slice](https://blog.golang.org/slices-intro).
- A slice is like an array, except that it's dynamically sized as you add and remove items. It's one of the most useful types in Go.
- You'll add a small slice to contain three greeting messages, then have your code return one of the messages randomly.

In greetings/greetings.go, change your code so it looks like the following.

``` Go
// Gopackage greetings

import (
    "errors"
    "fmt"
    "math/rand"
    "time"
)

// Hello returns a greeting for the named person.
func Hello(name string) (string, error) {
    // If no name was given, return an error with a message.
    if name == "" {
        return name, errors.New("empty name")
    }
    // Create a message using a random format.
    message := fmt.Sprintf(randomFormat(), name)
    return message, nil
}

// init sets initial values for variables used in the function.
func init() {
    rand.Seed(time.Now().UnixNano())
}

// randomFormat returns one of a set of greeting messages. The returned
// message is selected at random.
func randomFormat() string {
    // A slice of message formats.
    formats := []string{
        "Hi, %v. Welcome!",
        "Great to see you, %v!",
        "Hail, %v! Well met!",
    }

    // Return a randomly selected message format by specifying
    // a random index for the slice of formats.
    return formats[rand.Intn(len(formats))]
}

```

In this code, you:

- Add a randomFormat function that returns a randomly selected format for a greeting message.
- Note that randomFormat starts with a lowercase letter, making it accessible only to code in its own package (in other words, it's not exported).
- In randomFormat, declare a formats slice with three message formats. When declaring a slice, you omit its size in the brackets, like this: []string. This tells Go that the array underlying a slice can be dynamically sized.
- Use the [math/rand package](https://golang.org/pkg/math/rand/) to generate a random number for selecting an item from the slice.
- Add an [init function](https://golang.org/doc/effective_go.html#init) to seed the rand package with the current time. Go executes init functions automatically at program startup, after global variables have been initialized.
- In Hello, call the randomFormat function to get a format for the message you'll return, then use the format and name value together to create the message.
- Return the message (or an error) as you did before.

At the command line, change to the hello directory, then run hello.go to confirm that the code works. Run it multiple times, noticing that the greeting changes.

Oh -- don't forget to add Gladys's name (or a different name, if you like) as an argument to the Hello function call in hello.go: greetings. Hello("Gladys")

``` BASH
$ go build
$ ./hello
Great to see you, Gladys!

$ ./hello
Hi, Gladys. Welcome!

$ ./hello
Hail, Gladys! Well met!

```

### Return greetings for multiple people

### Add a test

### Compile and install the application

## References

- [How To Install Go and Set Up a Local Programming Environment on macOS](https://www.digitalocean.com/community/tutorials/how-to-install-go-and-set-up-a-local-programming-environment-on-macos)
- [Call code in an external package](https://golang.org/doc/tutorial/getting-started#call)

## Contributing

Pull requests are welcome. For major changes, please open an issue first to discuss what you **would** like to change.

Please make sure to update tests as appropriate.

## License

[MIT](https://choosealicense.com/licenses/mit/)
